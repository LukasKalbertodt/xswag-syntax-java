/// This file contains the grammar for Java 8.
///
/// The grammar is still highly incomplete! At every production/non-terminal
/// is a TODO-comment if it's not completed yet. However, these features won't
/// be "implemented" yet (read: we ignore them for now). Not implementing those
/// features doesn't count as "not completed":
///
/// - Annotations
/// - Generics
///

use ast;
use ast::ItemExt;
use lex::{Token, Keyword};
use base::code::{BytePos, Span};
use base::diag::Report;
use lalrpop_util::ParseError;
use super::{
    check_allowed_modifier,
    get_visibility,
    get_static,
    get_strictfp,
    get_abstract,
    get_default,
};

grammar(errors: &mut Vec<Report>);

extern {
    type Location = BytePos;
    type Error = Report;

    enum Token {
        // Variants of the Java-*Token*
        Word => Token::Ident(<String>),
        // Literal(Lit),

        // Keywords
        "abstract" => Token::KeyW(Keyword::Abstract),
        "assert" => Token::KeyW(Keyword::Assert),
        "boolean" => Token::KeyW(Keyword::Boolean),
        "break" => Token::KeyW(Keyword::Break),
        "byte" => Token::KeyW(Keyword::Byte),
        "case" => Token::KeyW(Keyword::Case),
        "catch" => Token::KeyW(Keyword::Catch),
        "char" => Token::KeyW(Keyword::Char),
        "class" => Token::KeyW(Keyword::Class),
        "const" => Token::KeyW(Keyword::Const),
        "continue" => Token::KeyW(Keyword::Continue),
        "default" => Token::KeyW(Keyword::Default),
        "do" => Token::KeyW(Keyword::Do),
        "double" => Token::KeyW(Keyword::Double),
        "else" => Token::KeyW(Keyword::Else),
        "enum" => Token::KeyW(Keyword::Enum),
        "extends" => Token::KeyW(Keyword::Extends),
        "final" => Token::KeyW(Keyword::Final),
        "finally" => Token::KeyW(Keyword::Finally),
        "float" => Token::KeyW(Keyword::Float),
        "for" => Token::KeyW(Keyword::For),
        "if" => Token::KeyW(Keyword::If),
        "goto" => Token::KeyW(Keyword::Goto),
        "implements" => Token::KeyW(Keyword::Implements),
        "import" => Token::KeyW(Keyword::Import),
        "instanceof" => Token::KeyW(Keyword::Instanceof),
        "int" => Token::KeyW(Keyword::Int),
        "interface" => Token::KeyW(Keyword::Interface),
        "long" => Token::KeyW(Keyword::Long),
        "native" => Token::KeyW(Keyword::Native),
        "new" => Token::KeyW(Keyword::New),
        "package" => Token::KeyW(Keyword::Package),
        "private" => Token::KeyW(Keyword::Private),
        "protected" => Token::KeyW(Keyword::Protected),
        "public" => Token::KeyW(Keyword::Public),
        "return" => Token::KeyW(Keyword::Return),
        "short" => Token::KeyW(Keyword::Short),
        "static" => Token::KeyW(Keyword::Static),
        "strictfp" => Token::KeyW(Keyword::Strictfp),
        "super" => Token::KeyW(Keyword::Super),
        "switch" => Token::KeyW(Keyword::Switch),
        "synchronized" => Token::KeyW(Keyword::Synchronized),
        "this" => Token::KeyW(Keyword::This),
        "throw" => Token::KeyW(Keyword::Throw),
        "throws" => Token::KeyW(Keyword::Throws),
        "transient" => Token::KeyW(Keyword::Transient),
        "try" => Token::KeyW(Keyword::Try),
        "void" => Token::KeyW(Keyword::Void),
        "volatile" => Token::KeyW(Keyword::Volatile),
        "while" => Token::KeyW(Keyword::While),

        // Variants of Java-*Seperator*
        // (   )   {   }   [   ]   ;   ,   .   ...   @   ::
        "(" => Token::ParenOp,
        ")" => Token::ParenCl,
        "{" => Token::BraceOp,
        "}" => Token::BraceCl,
        "[" => Token::BracketOp,
        "]" => Token::BracketCl,
        ";" => Token::Semi,
        "," => Token::Comma,
        "." => Token::Dot,
        "..." => Token::DotDotDot,
        "@" => Token::At,
        "::" => Token::ColonSep,

        // Variants of Java-*Operator*
        "=" => Token::Eq,
        ">" => Token::Gt,
        "<" => Token::Lt,
        "!" => Token::Bang,
        "~" => Token::Tilde,
        "?" => Token::Question,
        ":" => Token::Colon,
        "->" => Token::Arrow,

        "==" => Token::EqEq,
        ">=" => Token::Ge,
        "<=" => Token::Le,
        "!=" => Token::Ne,
        "&&" => Token::AndAnd,
        "||" => Token::OrOr,
        "++" => Token::PlusPlus,
        "--" => Token::MinusMinus,

        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Star,
        "/" => Token::Slash,
        "&" => Token::And,
        "|" => Token::Or,
        "^" => Token::Caret,
        "%" => Token::Percent,
        "<<" => Token::Shl,
        ">>" => Token::Shr,
        ">>>" => Token::ShrUn,

        "+=" => Token::PlusEq,
        "-=" => Token::MinusEq,
        "*=" => Token::StarEq,
        "/=" => Token::SlashEq,
        "&=" => Token::AndEq,
        "|=" => Token::OrEq,
        "^=" => Token::CaretEq,
        "%=" => Token::PercentEq,
        "<<=" => Token::ShlEq,
        ">>=" => Token::ShrEq,
        ">>>=" => Token::ShrUnEq,
    }
}


// ===========================================================================
// Definition of helper productions and macros
// ===========================================================================
Comma<T>: Vec<T> = {
    <head: T> <tail: ("," <T>)*> => {
        let mut v = vec![head];
        v.extend_from_slice(&tail);
        v
    }
};

#[inline]
Spanned<T>: ast::Spanned<T> = {
    <l:@L> <t:T> <r:@R> => ast::Spanned { inner: t, span: Span::new(l, r) },
};

// ===========================================================================
// Helper grammar definitions that are used in several sections
// ===========================================================================
// Type modifier is a merge of "InterfaceModifier" and "ClassModifier"
ModifierImpl = {
    "public",
    "protected",
    "private",
    "abstract",
    "static",
    "final",
    "synchronized",
    "native",
    "strictfp",
};
Modifier: Keyword = {
    ModifierImpl => if let Token::KeyW(kw) = <> { kw } else { unreachable!() }
};

Ident: ast::Ident = {
    <w: Spanned<Word>> => ast::Ident {
        name: w.inner,
        span: w.span,
     }
};

#[inline]
Path: ast::Path = {
    <head: Ident> <tail: ("." <Ident>)*> => {
        let mut v = vec![head];
        v.extend_from_slice(&tail);
        ast::Path {
            segments: v,
        }
    }
};

InterfaceType = ClassType;
ClassType = Path;

// ===========================================================================
// Grammar definitions in a top-down fashion/depth first search order
// ===========================================================================
// ~~~ Section 7 ~~~

// 7.3 (goal symbol)
pub CompilationUnit: ast::CompilationUnit = {
    <package: PackageDecl?>
    <imports: ImportDecl*>
    <types: TypeDecl*>
        =>
    {
        ast::CompilationUnit {
            package: package,
            imports: imports,
            types: types.into_iter().filter_map(|t| t).collect()
        }
    }
};

// 7.4
PackageDecl = { "package" <Path> ";" };

// 7.5
ImportDecl: ast::Import = {
    "import" <Path> ";" => ast::Import::SingleType(<>),
    "import" <Path> "." "*" ";" => ast::Import::TypeOnDemand(<>),
    "import" "static" <Path> ";" => ast::Import::SingleStatic(<>),
    "import" "static" <Path> "." "*" ";" => ast::Import::StaticOnDemand(<>),
};

// 7.6
TypeDecl: Option<ast::TypeDef> = {
    <ClassDecl> => Some(<>),
    <InterfaceDecl> => Some(<>),
    ";" => None
};


// ---------------------------------------------------------------------------
// ~~~ TODO: Section 9 ~~~

// 9.1
InterfaceDecl: ast::TypeDef = {
    <NormalInterfaceDecl> => ast::TypeDef::NormalInterface(<>),
    // TODO: AnnotationTypeDeclaration
};

// 9.1 GENE
NormalInterfaceDecl: ast::Interface = {
    <mods: Spanned<Modifier>*>
        "interface" <name: Ident>
        // GENE: type parameters
        <extends: ("extends" <Comma<InterfaceType>>)?>
        <body: InterfaceBody> =>
    {
        check_mods!(errors, "interface", mods,
            [Public, Private, Protected, Abstract, Static, Strictfp]
        );

        // check if unnecessary `abstract` keyword was specified
        if let Some(span) = get_abstract(&mods) {
            errors.push(Report::simple_warning(
                "interfaces are abstract by default. The `abstract` \
                    modifier is obsolete -- better remove it.",
                span
            ));
        }

        // check body
        let mut types = Vec::new();
        let mut constants = Vec::new();
        let mut methods = Vec::new();

        for item in body.into_iter().flat_map(|v| v) {
            match item {
                ast::TypeItem::Type(t) => {
                    // there are special rules for inner types

                    // TODO: spans are confusing right now (from type name)
                    // TODO: fix these stupid spans! For real now.
                    match t.vis() {
                        ast::Visibility::Private | ast::Visibility::Protected => {
                            errors.push(Report::simple_error(
                                "a member type of an interface is always \
                                    public. You must not use `private` or \
                                    `protected` modifiers.",
                                t.ident().map(|i| i.span).unwrap_or(Span::dummy())
                            ));
                        },
                        ast::Visibility::Public => {
                            errors.push(Report::simple_warning(
                                "a member type of an interface is implicitly \
                                    public. You don't need to explicitly mark \
                                    it public.",
                                t.ident().map(|i| i.span).unwrap_or(Span::dummy())
                            ));
                        }
                        _ => {},
                    }
                    // TODO: set visibility to public


                    types.push(t);
                },
                ast::TypeItem::Constant(c) => {
                    constants.push(c);
                },
                ast::TypeItem::Method(m) => {
                    methods.push(m);
                },
            }
        }

        ast::Interface {
            name: name,
            vis: get_visibility(&mods, errors).unwrap_or(ast::Visibility::Package),
            static_: get_static(&mods).is_some(),
            strictfp: get_strictfp(&mods).is_some(),
            extends: extends.unwrap_or(Vec::new()),
            types: types,
            constants: constants,
            methods: methods,
        }
    }
};

// 9.1.4
InterfaceBody = "{" <InterfaceMemberDecl*> "}";

// 9.1.4 TODO
#[inline]
InterfaceMemberDecl: Vec<ast::TypeItem> = {
    ConstantDecl => {
        <>.into_iter().map(|f| ast::TypeItem::Constant(f)).collect()
    },
    InterfaceMethodDecl => vec![ast::TypeItem::Method(<>)],
    InterfaceDecl => vec![ast::TypeItem::Type(<>)],
    ClassDecl => vec![ast::TypeItem::Type(<>)],
};

// 9.3
ConstantDecl: Vec<ast::Field> = {
    <mods: Spanned<Modifier>*>
    <ty: UnannType>
    <var_decls: VariableDeclaratorList> ";" => {
        check_mods!(errors, "constant", mods, [Public, Static, Final]);

        var_decls.into_iter().map(|(ident, dims)| {
            let mut ty = ty.clone();
            ty.dims += dims.unwrap_or(0);

            ast::Field {
                vis: ast::Visibility::Public,
                static_: true,
                final_: true,
                ty: ty.clone(),
                name: ident,
            }
        }).collect()
    }
};

// 9.4 TODO
InterfaceMethodDecl: ast::Method = {
    <mods: Spanned<Modifier>*> <header: MethodHeader> <body: MethodBody> => {
        check_mods!(errors, "interface-method", mods,
            [Public, Abstract, Default, Static, Strictfp]
        );

        let (ret_ty, name, params) = header;

        let is_static = get_static(&mods);
        let is_default = get_default(&mods);
        let is_abstract = get_abstract(&mods);

        // TODO: Check if more than one of static/default/abstract is set [E]
        // TODO: Check if abstract is combined with strictfp [E]
        // TODO: Add "public" useless modifier warning
        // TODO: Add "abstract" useless modifier warning

        ast::Method {
            vis: ast::Visibility::Public,
            name: name,
            ret_ty: ret_ty,
            static_: is_static.is_some(),
            final_: false,
            strictfp: get_strictfp(&mods).is_some(),
            abstract_: is_abstract.is_some(),
            default: is_default.is_some(),
            params: params,
        }
    }
};


// ---------------------------------------------------------------------------


// 8.1 ClassDeclaration TODO
ClassDecl: ast::TypeDef = {
    <NormalClassDecl> => ast::TypeDef::NormalClass(<>),
    // EnumDecl,
};

// 8.1 NormalClassDeclaration TODO
NormalClassDecl: ast::Class = {
    <modifier: Spanned<Modifier>*>
    "class" <class_name: Ident>
    <body: ClassBody> =>? {
        // check modifier
        Ok(ast::Class {
            name: class_name,
            vis: ast::Visibility::Public,
            methods: vec![],
            fields: body,
        })
    }
};


// 8.1.6
ClassBody: Vec<ast::Field> = {
    "{" <ClassBodyDecl*> "}" => {
        <>.into_iter().flat_map(|v| v.into_iter()).collect()
    }
};

// 8.1.6 TODO
ClassBodyDecl = {
    ClassMemberDecl,
    // TODO: ...
};

// 8.1.6 TODO
ClassMemberDecl = {
    FieldDecl,
    // MethodDecl,
    // ClassDecl,
    // InterfaceDecl,
};

// 8.3 TODO
FieldDecl: Vec<ast::Field> = {
    <mods: Spanned<FieldModifier>*>
    <ty: UnannType> <decls: VariableDeclaratorList> ";"
        =>? {
        // unwrap keywords from token
        let mods: Vec<_> = mods.iter().map(|&ast::Spanned { ref inner, span }|
            (
                if let &Token::KeyW(m) = inner { m } else { unreachable!() },
                span,
            )
        ).collect();

        // check Modifier
        let mut vis = ast::Visibility::Package;
        let mut first_vis = None;
        let mut static_ = false;
        let mut final_ = false;

        for &(m, span) in &mods {
            match m {
                Keyword::Public | Keyword::Private | Keyword::Protected => {
                    // check if there was a visibility modifier before this one
                    if let Some(prev_span) = first_vis {
                        let e = Report::simple_error(
                            "duplicate visibility modifier",
                            span
                        ).with_span_note(
                            "the first visibility modifier is already here",
                            prev_span
                        );
                        errors.push(e);
                    } else {
                        first_vis = Some(span);
                        vis = match m {
                            Keyword::Public => ast::Visibility::Public,
                            Keyword::Private => ast::Visibility::Private,
                            Keyword::Protected => ast::Visibility::Protected,
                            _ => unreachable!(),
                        };
                    }
                },
                Keyword::Static => {
                    if static_ {
                        let e = Report::simple_error(
                            "duplicate `static` modifier",
                            span
                        ).with_span_note(
                            "the modifier is already set here",
                            mods.iter()
                                .find(|&&(m, span)| m == Keyword::Static)
                                .map(|&(_, span)| span).unwrap()
                        );
                        errors.push(e);
                    } else {
                        static_ = true;
                    }
                },
                Keyword::Final => {
                    if final_ {
                        let e = Report::simple_error(
                            "duplicate `final` modifier",
                            span
                        ).with_span_note(
                            "the modifier is already set here",
                            mods.iter()
                                .find(|&&(m, span)| m == Keyword::Final)
                                .map(|&(_, span)| span).unwrap()
                        );
                        errors.push(e);
                    } else {
                        final_ = true;
                    }
                },
                _ => {},
            }
        }

        decls.into_iter().map(|decl| {
            let f = ast::Field {
                vis: vis,
                static_: static_,
                final_: final_,
                ty: ty.clone(),
                name: decl.0,
            };
            Ok(f)
        }).collect()
    }
};

FieldModifier = {
    "public",
    "protected",
    "private",
    "static",
    "final",
};

// 8.3
UnannType: ast::Type = {
    <ty: UnannTypeWithoutDim> <dims: Dims?> => {
        let mut ty = ty;
        ty.dims = dims.unwrap_or(0);
        ty
    }
};

// ~8.3 GENE, ANNO
UnannTypeWithoutDim: ast::Type = {
    // UnannPrimitiveType >> NumericType
    Spanned<NumericType> => ast::Type {
        name: ast::Path::single(ast::Ident {
            name: <>.inner.to_string(),
            span: <>.span,
        }),
        dims: 0,
    },
    // UnannPrimitiveType >> "boolean"
    Spanned<"boolean"> => ast::Type {
        name: ast::Path::single(ast::Ident {
            name: "boolean".into(),
            span: <>.span,
        }),
        dims: 0,
    },
    // UnannReferenceType >> UnannClassOrInterfaceType GENE, ANNO
    Path => ast::Type {
        name: <>,
        dims: 0,
    }

    // UnannReferenceType >> UnannTypeVariable GENE, ANNO
    // GENE: put this in again
    // UnannTypeVariable => ast::Type {
    //     name: <>,
    // },
};

// 8.3 GENE
// UnannTypeVariable = Ident;




// 8.3
VariableDeclaratorList = Comma<VariableDeclarator>;

// 8.3
VariableDeclarator = {
    <VariableDeclaratorId> ("=" <VariableInitializer>)?
};

// 8.3
VariableDeclaratorId = {
    <Ident> <Dims?>
};

// 8.3 TODO
VariableInitializer = "~";

// 8.4 GENE ANNO
MethodHeader: (ast::Type, ast::Ident, Vec<ast::FormalParameter>) = {
    <ret: Result> <decl: MethodDeclarator> <throws: Throws?> => {
        let mut ret_ty = ret;
        ret_ty.dims += decl.2.unwrap_or(0);

        (ret_ty, decl.0, decl.1.unwrap_or(vec![]))
    }
};

// 8.4 TODO
MethodDeclarator = {
    <Ident> "(" <FormalParameterList?> ")" <Dims?>
};

// 8.4.1 TODO
FormalParameterList = {
    Comma<FormalParameter>,
    // TODO: LastParameter (...)
    // TODO: ReceiverParameter
};

// 8.4.1 ANNO
FormalParameter: ast::FormalParameter = {
    <final_: "final"?> <ty: UnannType> <id: VariableDeclaratorId> => {
        let mut ty = ty;
        ty.dims += id.1.unwrap_or(0);
        ast::FormalParameter {
            ty: ty,
            name: id.0,
            final_: final_.is_some(),
        }
    }
};

// 8.4.5 TODO
#[inline]
Result = {
    UnannType,
    Spanned<"void"> => ast::Type {
        name: ast::Path::single(ast::Ident {
            name: "void".into(),
            span: <>.span,
        }),
        dims: 0,
    },
};

// 8.4.6 TODO GENE
Throws = "throws";

// 8.4.7 TODO
MethodBody = ";";


// ---------------------------------------------------------------------------
// ~~~ Section 4 [ANNO, -] ~~~

// 4.2 ANNO
PrimitiveType = {
    NumericType,
    "boolean",
};

// 4.2
NumericType = {
    IntegralType,
    FloatingPointType,
};

// 4.2
IntegralType = {
    "byte",
    "short",
    "int",
    "long",
    "char",
};

// 4.2
FloatingPointType = {
    "float",
    "double",
};

// 4.3 ANNO
Dims: u16 = {
    <dims: Spanned<("[" "]")+>> =>? {
        if dims.inner.len() > u16::max_value() as usize {
            Err(ParseError::User {
                error: Report::simple_error(
                    format!(
                        "too many dimensions! Do you really need a {} \
                            dimensional array?",
                        dims.inner.len(),
                    ),
                    dims.span,
                )
            })
        } else {
            Ok(dims.inner.len() as u16)
        }
    } ,
};
