/// This file contains the grammar for Java 8.
///
/// The grammar is still highly incomplete! At every production/non-terminal
/// is a TODO-comment if it's not completed yet. However, these features won't
/// be "implemented" yet (read: we ignore them for now). Not implementing those
/// features doesn't count as "not completed":
///
/// - Annotations
/// - Generics
///

use ast;
use lex::{Token, Keyword};
use base::code::{BytePos, Span};
use base::diag::Report;
use lalrpop_util::ParseError;
use super::{
    get_visibility,
    find_static,
    find_strictfp,
    find_abstract,
    forward_reports,
};

grammar(errors: &mut Vec<Report>);

extern {
    type Location = BytePos;
    type Error = Report;

    enum Token {
        // Variants of the Java-*Token*
        Word => Token::Ident(<String>),
        // Literal(Lit),

        // Keywords
        "abstract" => Token::KeyW(Keyword::Abstract),
        "assert" => Token::KeyW(Keyword::Assert),
        "boolean" => Token::KeyW(Keyword::Boolean),
        "break" => Token::KeyW(Keyword::Break),
        "byte" => Token::KeyW(Keyword::Byte),
        "case" => Token::KeyW(Keyword::Case),
        "catch" => Token::KeyW(Keyword::Catch),
        "char" => Token::KeyW(Keyword::Char),
        "class" => Token::KeyW(Keyword::Class),
        "const" => Token::KeyW(Keyword::Const),
        "continue" => Token::KeyW(Keyword::Continue),
        "default" => Token::KeyW(Keyword::Default),
        "do" => Token::KeyW(Keyword::Do),
        "double" => Token::KeyW(Keyword::Double),
        "else" => Token::KeyW(Keyword::Else),
        "enum" => Token::KeyW(Keyword::Enum),
        "extends" => Token::KeyW(Keyword::Extends),
        "final" => Token::KeyW(Keyword::Final),
        "finally" => Token::KeyW(Keyword::Finally),
        "float" => Token::KeyW(Keyword::Float),
        "for" => Token::KeyW(Keyword::For),
        "if" => Token::KeyW(Keyword::If),
        "goto" => Token::KeyW(Keyword::Goto),
        "implements" => Token::KeyW(Keyword::Implements),
        "import" => Token::KeyW(Keyword::Import),
        "instanceof" => Token::KeyW(Keyword::Instanceof),
        "int" => Token::KeyW(Keyword::Int),
        "interface" => Token::KeyW(Keyword::Interface),
        "long" => Token::KeyW(Keyword::Long),
        "native" => Token::KeyW(Keyword::Native),
        "new" => Token::KeyW(Keyword::New),
        "package" => Token::KeyW(Keyword::Package),
        "private" => Token::KeyW(Keyword::Private),
        "protected" => Token::KeyW(Keyword::Protected),
        "public" => Token::KeyW(Keyword::Public),
        "return" => Token::KeyW(Keyword::Return),
        "short" => Token::KeyW(Keyword::Short),
        "static" => Token::KeyW(Keyword::Static),
        "strictfp" => Token::KeyW(Keyword::Strictfp),
        "super" => Token::KeyW(Keyword::Super),
        "switch" => Token::KeyW(Keyword::Switch),
        "synchronized" => Token::KeyW(Keyword::Synchronized),
        "this" => Token::KeyW(Keyword::This),
        "throw" => Token::KeyW(Keyword::Throw),
        "throws" => Token::KeyW(Keyword::Throws),
        "transient" => Token::KeyW(Keyword::Transient),
        "try" => Token::KeyW(Keyword::Try),
        "void" => Token::KeyW(Keyword::Void),
        "volatile" => Token::KeyW(Keyword::Volatile),
        "while" => Token::KeyW(Keyword::While),

        // Variants of Java-*Seperator*
        // (   )   {   }   [   ]   ;   ,   .   ...   @   ::
        "(" => Token::ParenOp,
        ")" => Token::ParenCl,
        "{" => Token::BraceOp,
        "}" => Token::BraceCl,
        "[" => Token::BracketOp,
        "]" => Token::BracketCl,
        ";" => Token::Semi,
        "," => Token::Comma,
        "." => Token::Dot,
        "..." => Token::DotDotDot,
        "@" => Token::At,
        "::" => Token::ColonSep,

        // Variants of Java-*Operator*
        "=" => Token::Eq,
        ">" => Token::Gt,
        "<" => Token::Lt,
        "!" => Token::Bang,
        "~" => Token::Tilde,
        "?" => Token::Question,
        ":" => Token::Colon,
        "->" => Token::Arrow,

        "==" => Token::EqEq,
        ">=" => Token::Ge,
        "<=" => Token::Le,
        "!=" => Token::Ne,
        "&&" => Token::AndAnd,
        "||" => Token::OrOr,
        "++" => Token::PlusPlus,
        "--" => Token::MinusMinus,

        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Star,
        "/" => Token::Slash,
        "&" => Token::And,
        "|" => Token::Or,
        "^" => Token::Caret,
        "%" => Token::Percent,
        "<<" => Token::Shl,
        ">>" => Token::Shr,
        ">>>" => Token::ShrUn,

        "+=" => Token::PlusEq,
        "-=" => Token::MinusEq,
        "*=" => Token::StarEq,
        "/=" => Token::SlashEq,
        "&=" => Token::AndEq,
        "|=" => Token::OrEq,
        "^=" => Token::CaretEq,
        "%=" => Token::PercentEq,
        "<<=" => Token::ShlEq,
        ">>=" => Token::ShrEq,
        ">>>=" => Token::ShrUnEq,
    }
}


// ===========================================================================
// Definition of helper productions and macros
// ===========================================================================
Comma<T>: Vec<T> = {
    <head: T> <tail: ("," <T>)*> => {
        let mut v = vec![head];
        v.extend_from_slice(&tail);
        v
    }
};

#[inline]
Spanned<T> = { @L T @R };


// ===========================================================================
// Helper grammar definitions that are used in several sections
// ===========================================================================
// Type modifier is a merge of "InterfaceModifier" and "ClassModifier"
TypeModifierImpl = {
    "public",
    "protected",
    "private",
    "abstract",
    "static",
    "final",
    "strictfp",
};
TypeModifier: Keyword = {
    TypeModifierImpl =>
        if let Token::KeyW(kw) = <> { kw } else { unreachable!() }
};

Ident: ast::Ident = {
    <l:@L> <w:Word> <r:@R>  => ast::Ident {
        name: w,
        span: Span { lo: l, hi: r },
     }
};

#[inline]
Path: ast::Path = {
    <head: Ident> <tail: ("." <Ident>)*> => {
        let mut v = vec![head];
        v.extend_from_slice(&tail);
        ast::Path {
            segments: v,
        }
    }
};

InterfaceType = ClassType;
ClassType = Path;

// ===========================================================================
// Grammar definitions in a top-down fashion/depth first search order
// ===========================================================================
// ~~~ Section 7 ~~~

// 7.3 (goal symbol)
pub CompilationUnit: ast::CompilationUnit = {
    <package: PackageDecl?>
    <imports: ImportDecl*>
    <types: TypeDecl*>
        =>
    {
        ast::CompilationUnit {
            package: package,
            imports: imports,
            types: types.into_iter().filter_map(|t| t).collect()
        }
    }
};

// 7.4
PackageDecl = { "package" <Path> ";" };

// 7.5
ImportDecl: ast::Import = {
    "import" <Path> ";" => ast::Import::SingleType(<>),
    "import" <Path> "." "*" ";" => ast::Import::TypeOnDemand(<>),
    "import" "static" <Path> ";" => ast::Import::SingleStatic(<>),
    "import" "static" <Path> "." "*" ";" => ast::Import::StaticOnDemand(<>),
};

// 7.6
TypeDecl: Option<ast::Type> = {
    <ClassDecl> => Some(<>),
    <InterfaceDecl> => Some(<>),
    ";" => None
};


// ---------------------------------------------------------------------------
// ~~~ TODO: Section 9 ~~~

// 9.1
InterfaceDecl: ast::Type = {
    <NormalInterfaceDecl> => ast::Type::NormalInterface(<>),
    // TODO: AnnotationTypeDeclaration
};

// 9.1
NormalInterfaceDecl: ast::Interface = {
    <mods: Spanned<TypeModifier>*> "interface" <name: Ident>
        <extends: ("extends" <Comma<InterfaceType>>)?> InterfaceBody =>
    {
        // lookup visibility
        let vis = forward_reports(errors, || get_visibility(&mods));

        // check if unnecessary `abstract` keyword was specified
        if forward_reports(errors, || find_abstract(&mods)) {
            for &(lo, kw, hi) in &mods {
                if kw == Keyword::Abstract {
                    errors.push(Report::simple_warning(
                        "interfaces are abstract by default. The `abstract` \
                            modifier is obsolete -- better remove it",
                        Span { lo: lo, hi: hi }
                    ));
                }
            }
        }

        ast::Interface {
            name: name,
            vis: vis.unwrap_or(ast::Visibility::Package),
            static_: forward_reports(errors, || find_static(&mods)),
            strictfp: forward_reports(errors, || find_strictfp(&mods)),
            extends: extends.unwrap_or(Vec::new()),
        }
    }
};

// 9.1.4 TODO
InterfaceBody = "{" "}";


// ---------------------------------------------------------------------------

// 8.1 ClassDeclaration TODO
ClassDecl: ast::Type = {
    <NormalClassDecl> => ast::Type::NormalClass(<>),
    // EnumDecl,
};

// 8.1 NormalClassDeclaration TODO
NormalClassDecl: ast::Class = {
    <modifier: Spanned<TypeModifier>*>
    "class" <l:@L> <class_name: Ident> <r:@R>
    <body: ClassBody> =>? {
        // check modifier
        Ok(ast::Class {
            name: class_name,
            vis: ast::Visibility::Public,
            methods: vec![],
            fields: body,
        })
    }
};


// 8.1.6
ClassBody: Vec<ast::Field> = {
    "{" <ClassBodyDecl*> "}" => {
        <>.into_iter().flat_map(|v| v.into_iter()).collect()
    }
};

// 8.1.6 TODO
ClassBodyDecl = {
    ClassMemberDecl,
    // TODO: ...
};

// 8.1.6 TODO
ClassMemberDecl = {
    FieldDecl,
    // MethodDecl,
    // ClassDecl,
    // InterfaceDecl,
};

// 8.3 TODO
FieldDecl: Vec<ast::Field> = {
    <mods: (<@L> <FieldModifier> <@R>)*>
    <ty: UnannType> <decls: VariableDeclaratorList> ";"
        =>? {
        // unwrap keywords from token
        let mods: Vec<_> = mods.iter().map(|&(lo, ref t, hi)|
            (
                if let &Token::KeyW(m) = t { m } else { unreachable!() },
                Span {lo: lo, hi: hi }
            )
        ).collect();

        // check Modifier
        let mut vis = ast::Visibility::Package;
        let mut first_vis = None;
        let mut static_ = false;
        let mut final_ = false;

        for &(m, span) in &mods {
            match m {
                Keyword::Public | Keyword::Private | Keyword::Protected => {
                    // check if there was a visibility modifier before this one
                    if let Some(prev_span) = first_vis {
                        let e = Report::simple_error(
                            "duplicate visibility modifier",
                            span
                        ).with_span_note(
                            "the first visibility modifier is already here",
                            prev_span
                        );
                        errors.push(e);
                    } else {
                        first_vis = Some(span);
                        vis = match m {
                            Keyword::Public => ast::Visibility::Public,
                            Keyword::Private => ast::Visibility::Private,
                            Keyword::Protected => ast::Visibility::Protected,
                            _ => unreachable!(),
                        };
                    }
                },
                Keyword::Static => {
                    if static_ {
                        let e = Report::simple_error(
                            "duplicate `static` modifier",
                            span
                        ).with_span_note(
                            "the modifier is already set here",
                            mods.iter()
                                .find(|&&(m, span)| m == Keyword::Static)
                                .map(|&(_, span)| span).unwrap()
                        );
                        errors.push(e);
                    } else {
                        static_ = true;
                    }
                },
                Keyword::Final => {
                    if final_ {
                        let e = Report::simple_error(
                            "duplicate `final` modifier",
                            span
                        ).with_span_note(
                            "the modifier is already set here",
                            mods.iter()
                                .find(|&&(m, span)| m == Keyword::Final)
                                .map(|&(_, span)| span).unwrap()
                        );
                        errors.push(e);
                    } else {
                        final_ = true;
                    }
                },
                _ => {},
            }
        }

        decls.into_iter().map(|decl| {
            let f = ast::Field {
                vis: vis,
                static_: static_,
                final_: final_,
                ty: "<TODO>".into(),
                name: decl,
            };
            Ok(f)
        }).collect()
    }
};

FieldModifier = {
    "public",
    "protected",
    "private",
    "static",
    "final",
};

UnannType = "%";

VariableDeclaratorList = Comma<VariableDeclarator>;

VariableDeclarator = {
    // VariableDeclaratorId ("=" <VariableInitializer>)?
    VariableDeclaratorId
};

VariableDeclaratorId = {
    // <id: Ident> <dims: Dims?>;
    Ident
};

VariableInitializer = "~";
